<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Satellite Sky Viewer</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: black;
      color: white;
      font-family: sans-serif;
    }
    #toggleBtn {
      position: absolute;
      top: 10px;
      left: 10px;
      padding: 8px 16px;
      background: rgba(255, 255, 255, 0.1);
      border: none;
      color: white;
      cursor: pointer;
      z-index: 10;
    }
    #debug {
      position: absolute;
      top: 10px;
      right: 10px;
      padding: 8px 12px;
      background: rgba(0, 0, 0, 0.5);
      color: #0f0;
      font-size: 14px;
      z-index: 10;
      white-space: pre-wrap;
      max-width: 300px;
    }
    canvas {
      display: block;
    }
  </style>
</head>
<body>
  <button id="toggleBtn">Show Space Junk</button>
  <div id="debug">Loading...</div>
  <script src="https://cdn.jsdelivr.net/npm/three@0.160.1/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/satellite.js@5.0.1/dist/satellite.min.js"></script>

  <script>
    let scene, camera, renderer;
    let mode = 'sat';
    const satGroup = new THREE.Group();
    const debugDiv = document.getElementById('debug');

    init();
    animate();
    loadTLEs();

    document.getElementById('toggleBtn').onclick = () => {
      mode = mode === 'sat' ? 'junk' : 'sat';
      document.getElementById('toggleBtn').innerText = mode === 'sat' ? 'Show Space Junk' : 'Show Satellites';
      loadTLEs();
    };

    function init() {
      scene = new THREE.Scene();
      camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
      camera.position.z = 0;
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);
      scene.add(satGroup);

      // Wireframe sphere for visual reference
      const geometry = new THREE.SphereGeometry(10, 32, 32);
      const wireframe = new THREE.WireframeGeometry(geometry);
      const line = new THREE.LineSegments(wireframe);
      line.material.depthTest = false;
      line.material.opacity = 0.2;
      line.material.transparent = true;
      scene.add(line);

      window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });

      if (window.DeviceOrientationEvent) {
        window.addEventListener('deviceorientation', function(event) {
          const alpha = event.alpha ? THREE.MathUtils.degToRad(event.alpha) : 0;
          const beta = event.beta ? THREE.MathUtils.degToRad(event.beta) : 0;
          const gamma = event.gamma ? THREE.MathUtils.degToRad(event.gamma) : 0;

          const euler = new THREE.Euler(beta, alpha, -gamma, 'YXZ');
          camera.quaternion.setFromEuler(euler);
        }, true);
      }
    }

    async function loadTLEs() {
      satGroup.clear();
      debugDiv.innerText = 'Loading satellite data...';
      const url = mode === 'sat'
        ? 'https://celestrak.org/NORAD/elements/active.txt'
        : 'https://celestrak.org/NORAD/elements/1999-025.txt';

      try {
        const response = await fetch(url);
        const tleData = await response.text();
        const tleLines = tleData.split('\\n').filter(l => l.trim().length);

        const satrecs = [];
        let parseErrors = 0;
        for (let i = 0; i < tleLines.length; i += 3) {
          const name = tleLines[i];
          const line1 = tleLines[i+1];
          const line2 = tleLines[i+2];
          try {
            const satrec = satellite.twoline2satrec(line1, line2);
            satrecs.push({ name, satrec });
          } catch (err) {
            console.warn('TLE parse error', name);
            parseErrors++;
            continue;
          }
        }

        navigator.geolocation.getCurrentPosition(pos => {
          const observerGd = {
            longitude: satellite.degreesToRadians(pos.coords.longitude),
            latitude: satellite.degreesToRadians(pos.coords.latitude),
            height: 0.01
          };

          const date = new Date();
          const gmst = satellite.gstime(date);
          let shownCount = 0;
          let totalProcessed = 0;
          let propagationErrors = 0;

          satrecs.forEach(({ name, satrec }) => {
            totalProcessed++;
            const positionAndVelocity = satellite.propagate(satrec, date);
            if (!positionAndVelocity.position) {
              propagationErrors++;
              return;
            }

            const positionEcf = satellite.eciToEcf(positionAndVelocity.position, gmst);
            const lookAngles = satellite.ecfToLookAngles(observerGd, positionEcf);

            if (lookAngles.elevation > 0) {
              const radius = 10;
              const az = lookAngles.azimuth;
              const el = lookAngles.elevation;
              const x = radius * Math.cos(az) * Math.cos(el);
              const y = radius * Math.sin(el);
              const z = radius * Math.sin(az) * Math.cos(el);

              const dot = new THREE.Mesh(
                new THREE.SphereGeometry(0.05),
                new THREE.MeshBasicMaterial({ color: 0x00ffff })
              );
              dot.position.set(x, y, z);

              const label = makeLabel(name);
              label.position.set(x, y - 0.3, z);

              satGroup.add(dot);
              satGroup.add(label);
              shownCount++;
            }
          });

          debugDiv.innerText = 
            `Total TLEs: ${satrecs.length}
Parsed successfully: ${satrecs.length - parseErrors}
Parse errors: ${parseErrors}
Total processed: ${totalProcessed}
Propagation errors: ${propagationErrors}
Satellites visible: ${shownCount}`;
        }, err => {
          console.error('Geolocation error:', err);
          debugDiv.innerText = 'Geolocation error.';
        });
      } catch (error) {
        console.error('Error fetching TLE data:', error);
        debugDiv.innerText = 'Error fetching TLE data.';
      }
    }

    function makeLabel(text) {
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      ctx.font = '24px sans-serif';
      canvas.width = ctx.measureText(text).width;
      canvas.height = 30;
      ctx.fillStyle = 'white';
      ctx.fillText(text, 0, 24);

      const texture = new THREE.CanvasTexture(canvas);
      const material = new THREE.SpriteMaterial({ map: texture });
      const sprite = new THREE.Sprite(material);
      sprite.scale.set(1, 0.3, 1);
      return sprite;
    }

    function animate() {
      requestAnimationFrame(animate);
      renderer.render(scene, camera);
    }
  </script>
</body>
</html>
